# Replicating Notion's Multi-View Databases in Obsidian: A Comparative Analysis of Plugins
## 1 Introduction and Analytical Framework

This chapter establishes the foundational framework for the comparative analysis of Obsidian plugins against Notion's database functionality. It begins by defining Notion's database as the benchmark, synthesizing its core features from the reference materials. The chapter then delineates the key evaluation criteria for assessing Obsidian plugins, focusing on data source flexibility, view customization, interactivity, and integration. Finally, it outlines the methodology for the subsequent comparative analysis, specifying that the evaluation will be structured around the four primary view types (Table, Board, Calendar, Gallery) to systematically assess how well each plugin replicates Notion's corresponding view functionality and user experience.

### 1.1 Defining the Benchmark: Core Features of Notion Databases

To establish a clear benchmark, this section synthesizes the reference materials to define the core features of Notion's database system. Notion's flexibility is built upon a **block-based data model**, where every piece of content—including text, images, and database rows—is a dynamic block with a unique ID, properties, and a type[^1]. This foundational architecture enables the structural manipulation and nesting of information that powers its databases.

A single Notion database can be displayed in six distinct view types, each serving a specific purpose[^2][^3][^4][^5]:
*   **Table View**: The default view, presenting data in a spreadsheet-like grid of rows and columns, ideal for a high-level overview and quick editing[^2][^4][^5].
*   **Board (Kanban) View**: Groups database pages into columns based on a property (like status, assignee, or priority), enabling drag-and-drop workflow management[^6][^2][^4].
*   **List View**: A minimalist, vertical list layout best for collecting specific types of pages or documents[^2][^4].
*   **Calendar View**: Visualizes database entries on a calendar based on their date properties, suitable for event planning and deadline tracking[^2][^4][^5].
*   **Gallery View**: Displays pages in a visual grid, highlighting page covers or media properties, perfect for mood boards or portfolios[^2][^4].
*   **Timeline View**: Functions as a Gantt chart, plotting items with start and end dates on a timeline to visualize project duration and schedules[^2][^4].

Beyond layout, Notion databases offer powerful data manipulation tools. Users can apply **filters** to show only items meeting specific criteria, using nested `AND`/`OR` logic[^2]. **Sorting** allows ordering items by any property[^2], and **grouping** lets users categorize and collapse data based on property values[^2]. **Relations and Rollups** enable linking entries across different databases and aggregating data (e.g., summing values from related items), creating a powerful relational system[^7][^8].

However, this power comes with scalability considerations. **Performance can degrade noticeably with databases containing over 5,000 records**, leading to slower loading and interaction times compared to dedicated database tools[^9][^10]. This establishes a practical upper bound for the benchmark against which Obsidian's local, file-based performance can be contrasted.

### 1.2 Evaluation Criteria for Obsidian Database Plugins

Based on the Notion benchmark and the observed landscape of Obsidian solutions, the following criteria are established to evaluate the effectiveness of plugins aiming to replicate database functionality:

1.  **Data Source Flexibility**: A core strength of Obsidian is its decentralized, file-based nature. Effective plugins must offer flexible ways to define what constitutes a "database record." This includes sourcing from:
    *   **Folders**: Treating all notes within a specific folder as records[^11][^12].
    *   **Tags & Metadata**: Using tags or specific YAML frontmatter properties (e.g., `type: "project"`) to identify relevant notes[^11][^12].
    *   **Dataview Queries**: Leveraging the powerful query language of Dataview to define complex, dynamic data sources[^11][^12].
    *   **Dedicated Notes**: Some plugins may create database entries that are not directly linked to individual Markdown files, representing a different data model[^12].

2.  **View Customization and Fidelity**: This criterion assesses how well a plugin emulates the look, feel, and specific interactions of a Notion view. Key aspects include:
    *   **Layout Control**: Ability to adjust card size, column order/width, text alignment, and property visibility[^6][^11].
    *   **Visual Styling**: Support for images on cards, colored groups, and other visual cues present in Notion[^6].
    *   **Interaction Fidelity**: Faithful replication of core interactions, such as drag-and-drop card movement in a Kanban board or seamless date navigation in a calendar.

3.  **Interactivity and Data Manipulation**: Moving beyond passive visualization, this evaluates the plugin's capability for inline data manipulation, mirroring Notion's seamless editing experience.
    *   **Inline Editing**: Can users edit property values (text, selects, dates) directly within the table or card view?[^11]
    *   **Record Management**: Can new notes/records be created, or existing ones deleted, from within the plugin's interface?[^11]
    *   **Dynamic Filtering/Sorting**: Are filters and sorts user-configurable through a UI, or are they static and defined only in code?

4.  **Integration and Ecosystem Compatibility**: Any solution must respect Obsidian's core philosophy and integrate well with its ecosystem.
    *   **Markdown & Portability**: Does the plugin store data in standard Markdown/YAML, ensuring long-term data portability and independence from the plugin itself? This addresses concerns raised about tools like Dataview, where queries become non-functional code blocks in other editors[^13].
    *   **Plugin Interoperability**: Does it work with other core plugins (like Templates, Outliner) or community plugins (like Tasks, Periodic Notes)?
    *   **Performance**: Given the local nature of Obsidian, how does the plugin perform with large numbers of notes, especially compared to Notion's known scaling limits?

### 1.3 Methodology for Comparative Analysis Across View Types

To provide a structured and meaningful comparison, the analysis in subsequent chapters will be organized around four of Notion's primary view types: **Table**, **Board (Kanban)**, **Calendar**, and **Gallery**. These views represent distinct paradigms for data interaction and visualization. List and Timeline views will be discussed within relevant sections where plugin functionality overlaps.

For each view type, the analysis will follow a consistent three-part methodology:

1.  **Benchmark Definition**: First, it will detail Notion's implementation and feature set for that specific view, drawing directly from the reference materials. For example, for the Board view, this will include grouping mechanics, column calculations, and card preview options[^6]. For the Calendar view, it will cover date-based display and integration with daily notes[^4].

2.  **Plugin Evaluation**: Second, it will systematically identify and evaluate the most relevant Obsidian plugins that attempt to replicate that view's functionality. Plugins like DB Folder, DataLoom, Dataview/Datacore, and various calendar plugins (as identified in Search Results 25, 32, 34, 35) will be assessed against the evaluation criteria established in Section 1.2.

3.  **Gap and Strength Analysis**: Finally, the analysis will synthesize findings to highlight the **key gaps** between the plugin's offering and the Notion benchmark, the **unique strengths or adaptations** of the Obsidian approach, and any **workflow complexities or trade-offs** introduced. This will move beyond a simple feature checklist to assess the practical usability and completeness of each solution within the Obsidian ecosystem.

This structured, view-by-view methodology ensures a comprehensive and fair comparison, directly addressing the core user need to understand which Obsidian plugins can effectively replicate specific aspects of Notion's multi-view database experience.

## 2 Table View Solutions: From Queries to Native Bases

This chapter conducts a detailed comparative analysis of Obsidian plugins that provide table-style data presentation, directly addressing the first view type in the established methodology. It systematically evaluates Dataview (including its DQL syntax, DataviewJS, and performance considerations), the emerging native Obsidian Bases, the Enhanced Tables plugin, and Advanced Tables. The analysis applies the evaluation criteria from Chapter 1—data source flexibility, view customization, interactivity, and integration—to each solution. It focuses on verifying their capabilities in core table functions like sorting, filtering, pagination, metadata display, and inline editing. A central theme is the contrast between the declarative, query-based approach of Dataview and the more direct, spreadsheet-like interaction model of Bases and Enhanced Tables. The chapter synthesizes findings to highlight the key gaps and strengths of each solution relative to the Notion Table View benchmark, providing actionable insights for users selecting a table implementation.

### 2.1 Dataview Ecosystem: The Query-Powered Foundation

The Dataview plugin, first released in 2021 and boasting nearly 3 million downloads, established the foundational paradigm for query-based data presentation in Obsidian[^14]. Its core strength lies in the **Dataview Query Language (DQL)**, a SQL-like syntax that allows users to programmatically define dynamic views of their vault's data[^15]. A DQL query follows a structured pattern, beginning with a mandatory **Query Type** (`TABLE`, `LIST`, `TASK`, or `CALENDAR`), optionally followed by a `FROM` command to specify a data source (e.g., a folder or tag), and then additional data commands like `WHERE`, `SORT`, `GROUP BY`, and `LIMIT`[^15]. This structure enables powerful, flexible aggregation of data from across notes based on folders, tags, and frontmatter properties.

**However, Dataview's design embodies a fundamental trade-off.** It excels as a powerful, code-defined reporting engine but lacks the native, interactive user interface of a true spreadsheet-like table. **Dataview is not interactive; it's for gathering and viewing data but not for doing anything other than viewing**[^14]. Changing the sort order or applying a filter requires manually editing the query code itself, not clicking UI controls. This limitation has been a long-standing point of discussion in the community. A 2021 feature request explicitly asked for "responsive views" with client-side filtering and sorting for Dataview tables, highlighting the gap between its powerful query engine and user-friendly interaction[^16]. The plugin's main developer acknowledged the challenge, noting that mapping UI changes back to the query language is difficult, and that a non-persistent, visual-only interaction layer could be a more immediate solution[^16].

The community has actively sought workarounds to bridge this interactivity gap. Users have requested examples of creating tables with sort buttons and filter fields using **DataviewJS** (the JavaScript API for Dataview), comparing the desired functionality to libraries like DataTables in R[^17]. Solutions shared by users involve defining filter and sort configurations in YAML frontmatter and manually triggering view refreshes via other plugins like Templater, indicating a complex, do-it-yourself approach rather than a polished, out-of-the-box feature[^17]. For learners, resources like the **Obsidian Example Vault for Dataview Queries** provide concrete, hands-on examples to overcome the initial learning curve associated with DQL and DataviewJS[^18].

Beyond the UI limitations, **Dataview faces significant performance and development challenges.** It is known to become sluggish with large vaults and can add one to two seconds (or more) to the app's load time, especially on mobile devices[^14]. Critically, the plugin has not received major updates in a long time, and its development has effectively stalled, as the main developer has focused on other projects[^14]. This stagnation has prompted the development of successors like Datacore, designed to fix speed issues, though it trades Dataview's accessible query syntax for the complexity of building React components[^14].

**In summary, Dataview represents the powerful, programmer-oriented end of the spectrum.** It offers unparalleled flexibility in sourcing and transforming data from across the vault through a declarative query language but requires users to accept a static, non-interactive output, performance concerns, and the need for manual code adjustments to change the view.

### 2.2 Obsidian Bases: The Native, Visual Editor Approach

**Obsidian Bases** represents a paradigm shift, offering an official, native solution that moves decisively towards a visual, direct-manipulation model akin to a spreadsheet or Notion's table view. As a core plugin currently in beta but nearing public release, Bases allows users to create "database-like views" of their notes entirely through a **visual editor**, with no coding required[^14][^19]. Each row in a Base corresponds to a file in the vault, and each column displays a property (frontmatter) from that file[^20]. This tight integration with Obsidian's file and property system is a defining characteristic.

The functionality of Bases aligns closely with several core Notion table interactions. Users can **sort** and **filter** the table using property values through intuitive UI controls[^19]. Crucially, Bases supports **inline editing**: changes made to a cell in the Base view are automatically written back to the corresponding property in the underlying Markdown file[^20]. This creates a seamless, two-way link between the visual interface and the data source. Bases also supports **custom formulas**, allowing users to create calculated columns based on other properties, adding a layer of computational power[^20].

**Practical case studies illustrate Bases' ideal use cases.** A user managing a pipeline of over 200 sci-fi short stories found Bases effective for tracking each story's status, category, and planned publication date after migrating data from a single-file array into individual note files with frontmatter[^20]. Similarly, managing a Pokémon card collection became more manageable in Bases than maintaining complex key-value pairs in a single file, despite the initial effort of creating individual note files[^20]. **These examples highlight a key requirement: Bases works best with structured, file-based data where each entity (story, card set) naturally resides in its own note with consistent frontmatter.**

**However, this design imposes specific limitations.** Bases can **only query data stored in properties** (frontmatter), not arbitrary content within the note body[^14]. Its view types are currently limited to **Table, List, Cards, and Map**[^19]. This makes it less suitable for dynamic, temporary, or highly complex data structures that are better handled by DataviewJS scripts. The aforementioned user case confirms this, noting that for ephemeral data like a frequently updated audiobook listening schedule, a DataviewJS array was preferable to creating and deleting numerous note files[^20].

**Therefore, Obsidian Bases serves as a powerful, user-friendly bridge for users who think in terms of files and properties.** It delivers a genuine, interactive table experience with sorting, filtering, and editing, but within the bounded context of Obsidian's native data model, sacrificing the ultra-flexible, query-anything capability of Dataview for immediacy and ease of use.

### 2.3 Enhanced Tables: Interactive Markdown Tables

The **Enhanced Tables** plugin takes a distinct, hybrid approach by adding advanced interactive controls to **standard Markdown tables** already present in a note. Inspired by DataLoom but committed to storing data in simple Markdown syntax rather than JSON, this plugin enhances tables specifically in **preview/view mode**[^21][^22]. Configuration is achieved by placing a YAML code block with the keyword `enhanced-tables` directly before the target Markdown table[^21].

The plugin's feature set is designed to make static Markdown tables behave like dynamic data grids. Key configurable features include:
*   **Sorting**: Defining a default sort column (with `-` prefix for descending) via the `sort` property[^21].
*   **Filtering**: Setting a default filter using a JavaScript expression (with access to a `$row` variable) via the `filter` property, and defining additional named filters for a dropdown selector via `filters`[^21].
*   **Pagination**: Configuring page size and selectable page sizes through the `pagination` property[^21].
*   **Column Typing & Formatting**: Specifying column types (string, number, date, boolean, enum) and custom formatting for dates, numbers, and boolean values[^21].
*   **Inline Editing (Experimental)**: Enabling in-place editing of cell values in view mode, with appropriate controls like checkboxes for booleans and datepickers for dates[^21][^22].

A significant technical feature is the **TableManager API**, which exposes a `TableManager` instance for programmatically manipulating Markdown table data within a file's content[^21]. This allows for advanced integrations, such as creating buttons that modify table data.

**However, Enhanced Tables operates under a specific scope constraint.** It enhances individual, pre-existing Markdown tables within a note. This is fundamentally different from Dataview (which generates a table by querying the vault) and Bases (which generates a table from file properties). **Its power is confined to making a single, complex table within a document interactive.** Community feedback notes that while multiple tables per note can be enhanced by prepending a YAML block to each, the visual presence of these configuration blocks in source mode can be distracting[^22]. The plugin's author clarifies that the TableManager API currently works on a single table index, which is an advanced consideration for developers[^22].

**In essence, Enhanced Tables is the optimal solution for creating sophisticated, self-contained interactive tables within a single note.** It does not aggregate data from across the vault but instead supercharges the presentation and user interaction with tabular data already authored in Markdown.

### 2.4 Synthesis: Paradigms, Gaps, and Selection Guidelines

The analysis reveals two primary, contrasting paradigms for table views in Obsidian, each with distinct trade-offs relative to the Notion benchmark.

| Paradigm | Key Plugins | Core Philosophy | Data Source | Interactivity & UI | Primary Gap vs. Notion |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Query-Based / Programmatic** | Dataview, Datacore | Declarative queries generate dynamic views from vault metadata. Power and flexibility for users comfortable with code. | Extremely flexible: folders, tags, frontmatter, inline fields, linked notes. | **Minimal native UI.** Views are static snapshots. Changing sort/filter requires editing the query code. | **Lacks persistent, client-side interactive controls.** The view is a query result, not a live, manipulable surface[^17][^16]. |
| **Direct-Manipulation / Visual** | Obsidian Bases, Enhanced Tables | WYSIWYG or near-WYSIWYG editing within a table interface. Accessibility and immediacy for visual thinkers. | **Bases:** File properties (frontmatter) only. <br> **Enhanced Tables:** A specific Markdown table in a note. | **High.** Native sorting, filtering, and (for Bases & experimental Enhanced) inline editing through UI controls. | **Bases:** Cannot query arbitrary note content, only properties[^14]. <br> **Enhanced Tables:** Limited to one table per configuration block, not a cross-vault view. |

**Advanced Tables**, while often mentioned in this context, serves a complementary but different purpose: it drastically improves the **editing experience** for Markdown table syntax but does not provide interactive filtering or sorting in the rendered view. It is a tool for creation, not for dynamic data exploration.

**Selection guidelines** can be derived by aligning user needs with plugin characteristics:

1.  **For Dynamic Dashboards & Cross-Note Reporting:** Choose **Dataview** (or **Datacore** for better performance if available). This is ideal if you need to aggregate data from hundreds of notes based on complex conditions (e.g., "show all tasks due this week from projects tagged #active"). Accept the trade-off of writing and maintaining queries.
2.  **For Managing Collections of Files / Notes:** Choose **Obsidian Bases**. This is the best choice if your data is naturally organized into individual note files with consistent frontmatter (e.g., a book library, project notes, contact list) and you want a Notion-like, editable table view of that collection.
3.  **For a Complex, Interactive Table Within a Single Note:** Choose **Enhanced Tables**. Use this when you have a detailed, standalone table in a note (e.g., a product feature comparison, a research data summary) that benefits from client-side sorting, filtering, and pagination for reader exploration.
4.  **For Efficiently Creating & Editing Markdown Table Syntax:** Choose **Advanced Tables**. This plugin is essential for anyone who frequently works with Markdown tables, as it automates formatting and provides spreadsheet-like navigation during editing.

**The fundamental insight is that no single Obsidian plugin fully replicates the integrated, multi-faceted table view of Notion.** Notion seamlessly combines a flexible data model, rich property types, and an interactive UI. In Obsidian, this functionality is fragmented: **Dataview provides the powerful, vault-wide query engine; Bases provides the native, interactive interface for file properties; and Enhanced Tables provides rich interactivity for static tables.** The user's choice depends on whether their priority is **query power**, **visual management of files**, or **interactivity within a document**.

## 3 Kanban View Implementations

This chapter conducts a detailed comparative analysis of Obsidian plugins that provide Kanban board functionality, following the methodology established in Chapter 1. It systematically evaluates leading solutions—including the Kanban plugin, Task Board, CardBoard, and Kanban Plus—against the Notion Board View benchmark, applying the core evaluation criteria of data source flexibility, view customization, interactivity, and integration. The analysis leverages the rich version history and feature details from the reference materials to provide a data-driven assessment of how each plugin replicates or diverges from Notion's integrated Kanban experience, focusing on their underlying data models, automation capabilities, and user interaction paradigms. The chapter synthesizes findings to highlight key gaps, unique strengths, and practical selection guidelines for users seeking a Notion-like Kanban workflow within Obsidian's local-first ecosystem.

### 3.1 Benchmarking Notion's Board View: Core Mechanics and User Experience

To establish a clear target for comparison, this section details the core mechanics of Notion's Board View, synthesizing its defining features from the analytical framework established in Chapter 1.1. The Notion Board View is not a standalone application but a dynamic visualization of a structured database. Its power stems from several integrated capabilities that Obsidian plugins must attempt to replicate or adapt.

**First, dynamic grouping is fundamental.** Any database page (record) is automatically sorted into columns based on the value of a selected property, most commonly a "Status" select or a "Person" relation property. This creates a visual workflow where the column definition is directly tied to the underlying data schema. **Second, seamless drag-and-drop interaction allows users to move cards between columns, which instantly updates the corresponding property value in the database record.** This bidirectional sync between visual action and data update is a hallmark of the experience.

**Third, rich card previews and inline editing enhance usability.** Each card can display a page cover, icon, and multiple properties (like dates, tags, or assignees). Editing these properties can often be done directly on the card or in a quick-edit pane without opening the full page. **Fourth, integrated column calculations**, such as counting cards or summing a numeric property within a column, provide at-a-glance insights into the workflow's state.

**Finally, the view is deeply integrated with other perspectives.** The same database can be instantly switched to a Table, Calendar, or Gallery view, maintaining all filters and sorts—a feature central to Notion's "multi-view" system. It's important to note that, as referenced in Chapter 1.1, this power can come at a performance cost with very large datasets (over 5,000 records), a point of contrast for Obsidian's local file processing. This set of features—dynamic grouping, interactive manipulation, rich previews, and view interoperability—forms the comprehensive benchmark against which Obsidian's Kanban solutions are measured.

### 3.2 Plugin Landscape Analysis: From Manual Boards to Automated Task Aggregators

The Obsidian plugin ecosystem offers a diverse range of Kanban implementations, which can be broadly categorized into two distinct philosophical approaches based on their core data model and automation level.

**1. Manual, Note-Centric Boards:** This category is exemplified by the classic **Kanban** plugin by mgmeyers, which is by far the most popular with over 2 million downloads[^23]. Its core philosophy is simplicity and direct control: a Kanban board is a single Markdown file where each column is a Markdown list. Cards are list items within these columns. This creates a **highly intuitive, WYSIWYG relationship** where editing the source Markdown directly changes the board. A notable fork, **Kanban Plus**, emerged from this base. Announced as a pre-release in August 2025, it was created because the original plugin "seems a bit out of maintenance," with many open pull requests and community discussions about alternatives[^24]. Kanban Plus aims to stay in sync with the original while adding thoughtful extensions, adhering to principles of being fast, local, and modular[^24].

**2. Automated, Task-Aggregating Boards:** This category shifts the paradigm from managing a board file to managing tasks scattered throughout the vault. Plugins automatically scan and aggregate these tasks into a centralized Kanban view.
*   **Task Board** is directly inspired by GitHub Projects. It scans the vault (or specific files filtered by YAML properties) to extract tasks and display them in a managed board[^25]. Its development has been rapid and feature-focused, with versions in 2025 adding mobile support, Tasks plugin integration, a Map View for dependencies, and a "Safe Guard" feature to prevent accidental overwrites[^25].
*   **CardBoard** takes a similar aggregator approach but with a different configuration model. It dynamically creates Kanban-style boards by scanning for Markdown tasks, supporting two column types: date-based (for daily notes) and tag-based (using `#tags` or frontmatter tags)[^26]. It emphasizes syncing task completion between the board and the original files[^27].

**The maturity and community trajectory of these plugins vary significantly.** The core Kanban plugin, while immensely popular, shows signs of slowed development, as indicated by its many open pull requests[^28]. In contrast, Task Board has maintained a consistent release cycle with major feature additions throughout 2025[^25]. CardBoard's latest version (0.7.9) was released two years ago from the reference point, suggesting a potentially stable but less actively developed state[^27]. This landscape forces users to choose not just features, but also between different models of data ownership and maintenance responsibility.

### 3.3 In-Depth Plugin Evaluation Against Notion's Benchmark

Applying the four evaluation criteria from Chapter 1.2 reveals the distinct capabilities and limitations of each major Kanban plugin.

**Data Source Flexibility:**
*   **Kanban & Kanban Plus:** Source data is **manual and board-centric**. Cards exist only as list items within the Kanban note file itself. This offers maximum control for board design but no automatic linkage to other notes or tasks in the vault. Kanban Plus adds the ability to move items to other associated files, creating a one-way link from the board to topic-specific notes[^24].
*   **Task Board:** Sources data **automatically from vault-wide task scanning**. It uses YAML property-value pairs in note frontmatter to create dynamic filters for which notes are scanned[^25]. This allows it to build a board from tasks scattered across many files, making it powerful for research documentation and project management where tasks are documented within relevant notes.
*   **CardBoard:** Also an automated aggregator, but its sourcing is tied to **specific task syntax**. It scans for unindented CommonMark task list items (`- [ ]`) and can understand due date formats from both the Tasks and Dataview plugins[^27]. Boards are defined by filters (file, path, tag), making it highly flexible for viewing a subset of vault tasks.

**View Customization & Fidelity:**
*   **Kanban Plugin:** Offers **extensive theming capabilities through CSS**. The community actively shares snippets to change lane colors, card backgrounds, and text[^29]. For instance, users can override background and text colors for all lane and card elements using `!important` flags in a CSS snippet[^29]. Its UI is mature and widely themed.
*   **Task Board:** Has invested heavily in **modern, responsive UI/UX**. Version 1.4.0 introduced major changes for mobile support, and later versions added card background colors based on tags, custom column types, and a Map View for visualizing task connections[^25]. Its "Dependency Flow Planning (DFP)" methodology, introduced alongside Map View, adds a unique project management layer[^25].
*   **CardBoard:** Provides **customizable columns and card highlights**. Users can define columns based on dates or tags, customize tag styling, and set card highlight colors based on due dates or specific tags via CSS[^27].

**Interactivity & Data Manipulation:**
*   **Drag-and-Drop:** This is a standard, built-in feature of the **Kanban** plugin. For **Task Board**, it was a planned feature initially slated for version 1.7.0 but was rescheduled for version 1.10.0 for more testing[^25]. **CardBoard** described drag-and-drop as a goal in its roadmap but its last update was years ago[^26][^27].
*   **Inline Editing & Sync:** **Kanban** allows editing card text directly on the board, which updates the underlying Markdown list. **Task Board** and **CardBoard** offer more sophisticated bidirectional sync. CardBoard syncs task completion and appends a timestamp[^27]. Task Board's "Safe Guard" feature (v1.6.0) compares note content with scanned content to prevent accidental overwrites, indicating deep integration[^25].
*   **Advanced Features:** **Task Board** stands out with features like Parent-Child task linking with dependency properties, and a setting to restrict parent-task completion if child-tasks are incomplete[^25]. **Kanban Plus** introduces "Copy to Calendar" integration, where a card's first hashtag matching a calendar name in the Full Calendar plugin can copy the item to that calendar and color the card accordingly[^24].

**Integration & Ecosystem Compatibility:**
*   **Tasks Plugin Integration:** This is a critical integration for power users. **Task Board** version 1.5.0 focused extensively on this, adding properties for Created, Start, Scheduled, and Cancelled dates, and supporting Recurring tasks[^25]. **CardBoard** added compatibility in version 0.6.0[^26]. However, a known limitation exists: when the Tasks plugin's Auto-Suggest is used in Kanban plugin cards, the dependencies suggestions are not available[^30].
*   **Calendar Integration:** **Kanban Plus** makes this a core feature with its "Copy to Calendar" integration, linking boards to the Full Calendar plugin[^24].
*   **API and Extensibility:** **Task Board** introduced a Task Board API in version 1.5.0, allowing for deeper custom integrations[^25]. The core **Kanban** plugin's open pull requests include community proposals for features like dynamic query lanes and custom task icons, reflecting a desire for deeper integration[^28].

### 3.4 Synthesis: Gaps, Strengths, and Practical Selection Guidelines

The comparative analysis reveals a fundamental architectural gap between Notion's database-driven Board View and the Obsidian plugin ecosystem. **Notion provides a unified relational model where a board is a live view of a structured dataset.** In Obsidian, this functionality is fragmented: users must choose between a **manual board** that is easy to control but isolated from their notes, or an **automated aggregator** that connects to their notes but introduces complexity in configuration and potential performance considerations.

**Key Gaps vs. Notion's Benchmark:**
1.  **Lack of a Unified Database Backend:** No Obsidian plugin offers a true relational database where a single "status" property update in a note automatically reflects across multiple, different Kanban boards (views). Each plugin implements its own data linking logic.
2.  **Limited Real-Time Collaboration:** A core weakness of Obsidian itself, as noted in user reviews, is that the free version does not support real-time collaboration[^31]. This makes any Kanban plugin unsuitable for the multiplayer project management that is a strength of Notion's boards.
3.  **Fragmented Feature Sets:** Advanced Notion features like integrated column calculations, rich property editing on cards, and seamless switching to other views are partially implemented across different plugins but not unified in one.

**Unique Strengths of the Obsidian Approach:**
1.  **Local-First Performance & Privacy:** All plugins operate on local Markdown files, avoiding cloud latency and giving users complete data ownership. This addresses a common complaint about Notion's performance with large databases[^32].
2.  **Deep Customization and Hacking:** Through CSS snippets (as seen with the Kanban plugin[^29]) and plugin APIs (like Task Board's[^25]), power users can mold the Kanban experience to their exact needs, far beyond Notion's customization limits.
3.  **Organic Integration with Notes:** Aggregator plugins like Task Board and CardBoard allow task management to emerge from within research notes or project documentation, supporting a "note-centric" workflow rather than forcing data into a separate database table.

**Practical Selection Guidelines:**

The choice of plugin depends heavily on the user's primary workflow and technical comfort. The following table summarizes the key decision factors:

| Plugin | Ideal User Profile | Core Strength | Key Limitation | Best For... |
| :--- | :--- | :--- | :--- | :--- |
| **Kanban (Core)** | The visual organizer who prefers direct control and simplicity. | **Manual, intuitive editing** within a note. Massive community support and theming. | Board is isolated from other notes. Manual card creation/updates. | Personal task tracking, project planning where the board itself is the primary artifact. |
| **Task Board** | The project manager or researcher with complex, scattered tasks and dependencies. | **Automated aggregation** from vault tasks, advanced features (dependencies, Map View, API). | Requires setup (YAML filters). More complex interface. | Managing software projects, research documentation, and workflows requiring task relationships and central oversight. |
| **CardBoard** | The task-focused user who wants automatic Kanban views based on tags and dates. | **Simple, automated views** of Markdown tasks. Good Tasks/Dataview compatibility. | Less active development. Limited to specific task syntax. | Getting a quick Kanban overview of tasks tagged or dated a certain way, with minimal configuration. |
| **Kanban Plus** | The user who wants calendar integration and enhanced features from a Kanban base. | **Calendar integration** ("Copy to Calendar"), modular feature additions. | Pre-release status. Dependent on the original plugin's foundation. | Users who schedule tasks from their boards and want a more integrated calendar experience. |

**Ultimately, replicating Notion's seamless Kanban experience in Obsidian requires accepting trade-offs.** Users gain unparalleled control, local speed, and data portability but must manage plugin complexity, configuration, and the absence of native real-time collaboration. The ecosystem does not provide a single drop-in replacement but offers powerful, specialized tools that can, with careful selection and setup, fulfill and even extend specific aspects of the Notion board paradigm within Obsidian's decentralized philosophy.

## 4 Calendar View Integrations

This chapter conducts a detailed comparative analysis of Obsidian plugins that provide calendar-based visualization of time-based data, following the methodology established in Chapter 1. It systematically evaluates the diverse plugin landscape against the Notion Calendar View benchmark, focusing on how events are sourced (from daily notes, task syntax, YAML frontmatter, or dedicated event notes), the types of views offered (simple navigation, full-featured scheduling, heatmaps), and their interoperability with the broader Obsidian ecosystem (Dataview, Tasks, Kanban). The analysis leverages the extensive reference materials to provide a data-driven assessment of each plugin's capabilities, limitations, and unique adaptations to Obsidian's local-first, file-based architecture. The chapter synthesizes findings to highlight key gaps relative to Notion's integrated experience, the unique strengths of the Obsidian approach, and practical selection guidelines for users seeking to manage schedules and visualize time-based data within their vault.

### 4.1 Benchmarking Notion's Calendar View: Event Sourcing and Visualization Paradigm

To establish a clear target for comparison, this section details the core mechanics of Notion's Calendar View as synthesized from the analytical framework in Chapter 1.1. The Notion Calendar View is not a standalone application but a dynamic, visual representation of a structured database. Its power stems from a unified, bidirectional data model where calendar entries are live views of database records filtered by date properties.

**The defining feature of Notion's Calendar View is its seamless integration with the underlying database.** A user can define a date property (e.g., "Event Date") or a date range property (e.g., "Start Date" and "End Date") within a database. Any record with a value in this property automatically appears on the calendar at the corresponding date(s). This creates a powerful paradigm where the calendar is a **filtered, time-ordered perspective** of the same dataset that can be viewed as a Table, Board, or Gallery. **Editing is fully bidirectional:** changes made directly on a calendar event (dragging to a new date, editing the title in a popover) are instantly written back to the database record, and vice versa. The calendar supports rich event previews, showing icons, properties, and even page content snippets.

**This integrated model stands in stark contrast to traditional calendar applications.** It eliminates the need for separate data entry and sync between a task/project manager and a calendar. However, as noted in Chapter 1.1, this power can come at a performance cost with very large datasets (over 5,000 records), a point of contrast for Obsidian's local file processing. The Notion benchmark thus sets a high bar: a calendar that is not just a visualization tool, but an **interactive interface to a relational data system**, supporting single-day and date-range events, instant view switching, and deep property integration. This benchmark frames the evaluation of how Obsidian plugins, operating within a decentralized, file-based architecture, attempt to replicate or adapt this experience.

### 4.2 Plugin Landscape Analysis: From Daily Note Navigation to Full-Featured Scheduling

The Obsidian plugin ecosystem offers a wide array of calendar solutions, which can be structurally categorized into three primary philosophical and functional groups based on their core purpose and data model. Download statistics and feature descriptions from the reference materials reveal a clear segmentation[^33].

**1. Navigation & Visualization Plugins:** This category focuses on using the calendar as a **navigation hub and activity tracker for periodic notes**. The quintessential example is **Calendar by Liam Cain**, with over 2.3 million downloads[^33]. Its primary function is to visualize and navigate between daily notes. It reads the user's Daily Note settings to understand date formats and templates. Its signature feature is a "word count meter" (configurable dots) that approximates writing volume per day[^34]. A similar plugin, **Daily notes calendar** by bartkessels, allows navigation to daily and weekly notes using a calendar view and supports creating various periodic notes (daily, weekly, monthly, quarterly, yearly)[^33][^35]. These plugins are **note-centric**; the calendar cell represents the existence and metadata of a note file for that date, not a scheduled event.

**2. Event Management & Scheduling Plugins:** This category aims to bring **traditional calendar functionality** into Obsidian for managing appointments, meetings, and schedules. The leading plugin is **Full Calendar** by Davis Haupt (@davish), with over 378,000 downloads[^33][^36]. It integrates the FullCalendar.io library, allowing users to manage events and calendars alongside their notes. Each event is stored as a separate note with special YAML frontmatter, enabling note-taking and linking[^37][^36]. It supports multiple views (day, week, month) and can pull events from note frontmatter, daily notes, or read-only external calendars (ICS/CalDAV)[^37]. **Big Calendar** by Boninall (57,178 downloads) offers a similar comprehensive feature set with day, week, month, and agenda views[^33][^38][^39]. Its innovation lies in automatically parsing and displaying time-based tasks and entries from daily notes using TASKS, DATAVIEW, or KANBAN formats[^33][^40][^39]. These plugins are **event-centric**, creating or referencing dedicated data structures for scheduled occurrences.

**3. Specialized Visualization Plugins:** This category provides **unique, data-driven visualizations** that go beyond traditional calendars. The most prominent is **Heatmap Calendar** by Richard Slettevoll (145,015 downloads), which renders a GitHub-style activity heatmap for tracking goals, habits, tasks, or any quantifiable daily metric[^33][^41][^42]. It is designed to be used with DataviewJS for data aggregation. **Time Ruler** by Joshua Tazman Reinier (58,944 downloads) combines a task list and a calendar view into a drag-and-drop timeline, integrating specifically with the Tasks and Full Calendar plugins[^33]. Other specialized plugins include **Habit Calendar** for DataviewJS monthly habit tracking and various culturally specific calendars (e.g., Dust Calendar, Chinese Calendar for lunar dates)[^33].

**The fundamental difference between these categories lies in their data model and primary intent.** Navigation plugins treat the calendar as an **index into a collection of notes**. Event management plugins treat it as a **surface for managing time-bound objects**. Specialized plugins treat it as a **canvas for data visualization**. This segmentation means that no single Obsidian plugin attempts to be the all-encompassing "database calendar view"; instead, the ecosystem provides specialized tools for distinct use cases.

### 4.3 In-Depth Plugin Evaluation Against Core Criteria

Applying the four evaluation criteria from Chapter 1.2 reveals the distinct capabilities, trade-offs, and integration patterns of the major calendar plugins.

**Data Source Flexibility:**
*   **Calendar / Daily notes calendar:** Sources are **strictly based on note filenames and dates**. They locate notes matching a specific date pattern (e.g., `YYYY-MM-DD.md`) within configured folders[^34]. They do not parse content for events.
*   **Full Calendar:** Sources from **dedicated event note frontmatter** (primary model), **frontmatter on any note**, or **event lists in daily notes**[^37][^36]. It also supports **read-only external calendars (ICS/CalDAV)**, a significant feature for interoperability[^37][^36].
*   **Big Calendar:** Sources by **automatically parsing note content**. It identifies events from daily notes by recognizing specific time formats: tasks with times (e.g., `- [ ] 15:00 Meeting`), time blocks (e.g., `- 19:00 Dinner`), and plain tasks[^39]. This allows it to build a schedule directly from notes without requiring separate event creation.
*   **Heatmap Calendar:** Sources data **exclusively via DataviewJS queries**. Users must annotate their daily notes with data (e.g., `exercise:: 30`) and then write a DataviewJS script to collect this data into a `calendarData` object for rendering[^41][^42]. This offers maximum flexibility but requires technical setup.

**View Customization & Fidelity:**
*   **Visual Types:** Plugins offer a range of views. **Full Calendar** and **Big Calendar** provide comprehensive day, week, month, and agenda views[^38][^39][^36]. The **Calendar** plugin offers a simple month grid[^34]. **Heatmap Calendar** provides a unique annual density overview[^41]. **Time Ruler** offers a hybrid timeline view[^33].
*   **Customization:** Most allow some UI customization. The **Calendar** plugin can be heavily themed via CSS variables in `obsidian.css`[^34]. **Heatmap Calendar** allows extensive customization of colors, intensity scales, and global color schemes via plugin settings[^41]. **Big Calendar** allows configuring the first day of the week and event display formats[^39].

**Interactivity & Data Manipulation:**
*   **Interactivity Spectrum:** There is a clear divide. **Full Calendar** and **Big Calendar** are designed for **high interactivity**, allowing users to create, edit, and drag events directly on the calendar view, with changes syncing back to the underlying notes[^39][^36]. In contrast, the **Calendar** and **Daily notes calendar** plugins are primarily **read-only navigators**; clicking a date opens or creates the corresponding note, but you cannot create an "event" by clicking on the calendar[^35][^34].
*   **Advanced Features:** **Full Calendar's** bidirectional editing with dedicated event notes is its core interactive feature[^37]. **Big Calendar's** click-to-jump-to-original-note and real-time updates on file changes enhance its interactivity[^39]. A notable integration is the ability to copy a Kanban card to Full Calendar as an all-day event, keeping both views in sync—a feature motivated and quickly implemented with the aid of AI coding tools[^43].

**Integration & Ecosystem Compatibility:**
*   **With Tasks Plugin:** This is a critical integration. **Big Calendar** explicitly parses and displays tasks using the TASKS format[^40][^39]. **Time Ruler** is built to integrate with Tasks, providing a drag-and-drop timeline for them[^33]. Community efforts like **Obsidian-Tasks-Calendar** provide Dataview snippets to visualize tasks in calendar views[^44].
*   **With Dataview:** Integration is deep, especially for query-powered visualizations. **Heatmap Calendar** is essentially a rendering engine for DataviewJS-collected data[^41][^42]. Users combine **Dataview and Full Calendar** to generate dynamic daily agendas, though they face challenges due to differing data structures between one-time and recurring events[^45].
*   **With Kanban:** The **Kanban plugin integration** with Full Calendar, as mentioned, allows duplicating cards to the calendar, creating a link between project tracking and scheduling[^43].
*   **The Standardization Gap:** A major interoperability hurdle is the **lack of a shared date and action format** across task and calendar plugins. As highlighted in a 2021 community discussion, different plugins (Kanban, Tasks, Reminders, CardBoard) used different syntaxes (`@[[date]]`, `:date:`, `([[date]] 8:35)`, `@due (date)`), preventing seamless data flow[^46]. Developers supported the idea of a standard (e.g., using `::` as a key-value separator, like `due:: [[2021-11-02]]`), but noted challenges in auto-detection and performance[^46]. This fragmentation is cited as a key reason for requesting a **core plugin to establish date/time standards**[^47].

### 4.4 Synthesis: Gaps, Ecosystem Strengths, and Selection Framework

The comparative analysis reveals that the Obsidian calendar plugin ecosystem is rich and capable but architecturally distinct from Notion's unified model. The functionality is fragmented across specialized tools, each excelling in a specific niche but requiring users to understand and choose between different paradigms.

**Key Architectural Gaps vs. Notion:**
1.  **Absence of a Unified Relational Backend:** **No Obsidian plugin provides a calendar that is a dynamic, editable view of a unified database table.** In Notion, the calendar is a lens on your data. In Obsidian, you must either create dedicated event notes (Full Calendar), rely on parsing specific syntax in existing notes (Big Calendar), or build custom queries (Heatmap Calendar). The data is not relationally connected by default.
2.  **Fragmented Event Creation and Management:** Notion allows creating a database record from any view. In Obsidian, the workflow differs per plugin: creating a daily note vs. creating an event note vs. writing a task in a note with a specific time format. There is no single, universal "Create event" action.
3.  **Limited Native Support for Date Ranges:** While plugins like Full Calendar and Big Calendar can display multi-day events, the underlying Markdown representation and querying for date ranges (e.g., for a trip) is less seamless than a dedicated database property. A feature request for **Bases to include a Calendar View** explicitly mentions the need for visualizing date ranges (start and end dates) for events like travel or reading, which current community plugins handle imperfectly[^48].

**Unique Strengths of the Obsidian Ecosystem:**
1.  **Unparalleled Customization and Specialization:** Users are not limited to a standard calendar. They can create **highly specialized visualizations** like the GitHub-style heatmap for habit tracking, which is not a native Notion feature. The ability to theme everything with CSS offers deep visual control.
2.  **Deep, File-Based Integration:** Calendar views can surface content directly from the fabric of your notes. **Big Calendar's** ability to show your schedule by parsing time blocks written naturally in daily notes is a powerful, organic integration that aligns with a note-centric workflow.
3.  **Local Performance and Data Ownership:** All processing happens locally on your Markdown files. For users with large vaults, this can mean more responsive interactions compared to Notion's web-based performance with large databases.
4.  **Community-Driven Innovation:** Integrations like **Kanban-to-Calendar sync** emerge from community needs and are implemented rapidly, sometimes aided by modern development tools[^43]. The ecosystem evolves to fill specific workflow gaps.

**Practical Selection Framework:**

Choosing the right calendar plugin depends entirely on the user's primary intent. The following table provides a clear guideline:

| Primary Need | Recommended Plugin(s) | Core Rationale | Key Considerations |
| :--- | :--- | :--- | :--- |
| **Simple navigation to daily/weekly notes & writing tracking** | **Calendar** (by Liam Cain) or **Daily notes calendar** | Optimized for visualizing and jumping between periodic notes. The word count meter provides passive activity insight. | Limited to note navigation; no event scheduling. Choose Daily notes calendar if you need monthly/quarterly note support[^35]. |
| **Managing appointments, meetings, and a traditional schedule** | **Full Calendar** or **Big Calendar** | Provide full-featured, interactive calendar interfaces with multiple views (day, week, month). Support event creation and management. | **Full Calendar** is better for dedicated event notes and external calendar sync. **Big Calendar** is better if your schedule emerges from tasks/time blocks within your daily notes[^39]. |
| **Tracking habits, goals, or any quantifiable daily metric over time** | **Heatmap Calendar** | Uniquely effective for long-term trend visualization using a color-intensity heatmap (like GitHub contributions). | Requires setup with DataviewJS to collect and pass data. Not for scheduling, purely for retrospective visualization[^41]. |
| **Time-blocking and visual task scheduling on a timeline** | **Time Ruler** | Combines a task list and calendar into a drag-and-drop timeline, ideal for planning your day. | Integrates specifically with the Tasks plugin. Offers a unique hybrid view not found in Notion[^33]. |
| **Viewing notes with date properties on a calendar** | **OZ Calendar** (or future Bases Calendar View) | Can display any note on a calendar based on a YAML date key, offering flexibility[^33]. | A feature request exists for a native **Calendar View in Obsidian Bases**, which would allow visualizing notes with date properties directly, potentially supporting date ranges[^48]. |

**Conclusion and Future Directions:**
The Obsidian calendar ecosystem effectively replicates *aspects* of Notion's Calendar View through a suite of specialized plugins, but it does not provide a single, drop-in replacement that matches Notion's seamless database integration. The gap is primarily architectural, stemming from Obsidian's decentralized, file-based model versus Notion's centralized, block-based database.

The community has clearly identified the need for greater standardization and native support. The discussion on a **shared date format**[^46] and the formal request for a **core time management plugin**[^47] highlight the desire to reduce fragmentation. The user request for a **Calendar View in Bases**[^48] points towards a potential future where a more unified, Notion-like calendar experience could emerge within Obsidian's native feature set, bridging the current gap between powerful specialization and cohesive user experience.

## 5 List and Gallery View Alternatives

This chapter conducts a detailed comparative analysis of Obsidian plugins that provide list, card, and masonry gallery views for notes and media, addressing the final view types in the established methodology. It systematically evaluates plugins like Obsidian Projects, Database Folder (DB Folder), Notes Explorer, and various gallery-specific plugins against the Notion List and Gallery View benchmarks. The analysis applies the core evaluation criteria—data source flexibility, view customization, interactivity, and integration—to determine whether these solutions function as passive visualizations or interactive, query-backed databases. A central focus is on assessing their filtering, sorting, and data-linking capabilities to clarify their role within a Notion-like multi-view system. The chapter synthesizes findings to highlight the architectural distinctions between comprehensive database plugins and specialized visualizers, providing clear selection guidelines for users seeking to organize and visualize collections of notes and files within Obsidian's ecosystem.

### 5.1 Benchmarking Notion's List and Gallery Views: Passive Display vs. Interactive Database

To establish a clear target, it is essential to understand that Notion's List and Gallery Views are not static displays but **dynamic, interactive interfaces to an underlying database**. The List View presents a minimalist, vertical list of database pages, ideal for collections like reading lists or directories. The Gallery View displays pages in a visual grid, emphasizing page covers, icons, or media properties, perfect for portfolios or mood boards.

The defining characteristic of these Notion views is their **bidirectional data flow and integration**. They are fully editable: clicking on a card or list item opens it for editing, and property values can often be modified directly within the view. More importantly, they share the same data model as the Table, Board, and Calendar views. A filter applied in one view persists when switching to another, and changes made anywhere are instantly reflected across all views. This seamless integration of visualization and data manipulation sets the high benchmark against which Obsidian plugins must be measured. The core question for evaluation is whether an Obsidian plugin offers a similar **interactive database experience** or serves primarily as a **passive presentation layer**.

### 5.2 Plugin Landscape: From Comprehensive Databases to Specialized Visualizers

The Obsidian ecosystem for list and gallery views is bifurcated into two primary philosophical categories, each with distinct goals and data models.

1.  **Comprehensive Database Plugins with Multi-View Support:** These plugins aim to replicate Notion's core database paradigm, where a single dataset can be visualized and manipulated through different layouts, including list and gallery/card views.
    *   **Obsidian Projects:** This plugin is designed as an integrated system for managing note-based projects[^49]. It defines a project as a collection of notes (e.g., from a folder or a Dataview query) and allows users to add multiple synchronized views of that data. It ships with four view types: Table, Board, Calendar, and **Gallery**[^49]. Its Gallery view configures a `Cover` field to display images on cards, creating a visually rich layout[^49].
    *   **Database Folder (DB Folder):** This plugin creates a Notion-like database based on folders, links, tags, or—critically—full Dataview queries[^12][^50]. It has its own type of view that occupies a whole pane and can display data in a table or other layouts[^12]. Its development features a clear roadmap, including long-term plans for features like Notion formulas and relationship databases[^12].

2.  **Specialized Visualization Plugins:** These plugins focus almost exclusively on rendering notes or media in aesthetically pleasing layouts, often prioritizing visual customization over deep data manipulation.
    *   **Notes Explorer:** A modification of the Cards view plugin, it allows exploring notes as cards in a Gallery view with fixed card height or a Masonry view with variable card height[^51]. It adds numerous features for visual customization, such as tag-based card coloring, hover previews, and performance optimizations (like reading only the first 20 lines of a note)[^51].
    *   **Dedicated Gallery Plugins:** The community offers several focused solutions, such as **Note Gallery** (a masonry gallery similar to Craft note view), **Image Gallery** (a zero-setup masonry image gallery), and **Page Gallery** (creates embeddable galleries from selected page contents)[^52]. These typically excel at presenting a curated set of notes or images with minimal configuration for data management.

This landscape forces a fundamental choice: users must decide between a plugin that manages data interactively but may have less visual flair (comprehensive databases) and one that offers stunning visualizations but treats the underlying notes as relatively static sources (specialized visualizers).

### 5.3 In-Depth Evaluation of Multi-View Database Plugins

This section applies the evaluation criteria to plugins that aim to provide a Notion-like, interactive database experience with list and gallery capabilities.

**Data Source Flexibility:**
*   **Obsidian Projects:** It primarily sources data from a **folder path**, but a significant feature is its ability to use a **Dataview query as a source**[^49]. However, projects configured this way are **read-only**, as the plugin cannot safely write back to dynamically queried notes[^49]. This creates a hybrid model where visualizations can be powerful, but interactivity is limited.
*   **Database Folder (DB Folder):** It offers superior flexibility, supporting folders, tags, links, and **full Dataview queries as a data source**[^12][^50]. A key differentiator is its ability to **convert a Dataview query into an editable database table**, bridging the gap between Dataview's query power and interactive editing[^12]. However, it requires each database entry to be linked to a file, which can be a constraint for some use cases[^12].

**View Customization & Fidelity:**
*   **Obsidian Projects' Gallery View:** It is configurable, allowing users to set a `Cover` field to pull images onto cards[^49]. The layout is a clean grid, but deep visual customization (like masonry or extensive CSS theming) is not its primary focus.
*   **DB Folder:** It provides a customizable view with features like a configurable footer showing statistics (percentage of empty cells, count of unique values, sum of numbers)[^53]. Its interface is designed for data interaction rather than artistic presentation.

**Interactivity & Data Manipulation:**
*   **Inline Editing:** Both plugins support editing data within their views. Projects allows editing note properties directly from its Table and Board views[^49]. DB Folder is built around the premise of editing metadata that is saved back to the target Obsidian note[^50].
*   **Filtering & Sorting:** This is where DB Folder excels. It provides a sophisticated, UI-driven filtering system where users can create individual filters or **group filters** with AND/OR relationships, and even nest group filters within each other for granular control[^53]. These filters hold priority over any source Dataview query filters[^53]. Both plugins support sorting columns.
*   **Record Management:** New notes/records can be created from within both interfaces, adhering to their respective data models.

**Integration & Ecosystem Compatibility:**
*   **DB Folder** demonstrates strong integration by offering a **custom view for the Projects plugin**, allowing its databases to be embedded within the Projects framework[^53][^49].
*   Both store data in standard Markdown files and frontmatter, ensuring portability. Their performance is tied to local file operations, which is generally fast but can require manual refresh in DB Folder after external changes like file renaming[^12].

**In summary, DB Folder emerges as the more powerful tool for creating an interactive, Notion-like database with advanced querying and filtering capabilities, while Projects offers a more integrated, multi-view system out of the box, albeit with some read-only limitations when using complex queries.**

### 5.4 Analysis of Specialized Gallery and Visualization Plugits

This section evaluates plugins whose primary design goal is visual presentation rather than comprehensive data management.

**Data Source Flexibility:**
These plugins typically have simpler, more constrained sourcing. **Notes Explorer**, for example, can be configured for specific folders and includes an `Exclude Folders` setting[^51]. It can also open a board view for a specific folder directly from the file explorer[^51]. **Image Gallery** and **Page Gallery** are often configured to target a specific set of files or attachments[^52]. They generally do not support sourcing from complex Dataview queries or tags across the vault.

**View Customization & Fidelity (Primary Strength):**
This is the core competency of specialized visualizers. They offer extensive customization options that far exceed typical database plugins:
*   **Layouts:** **Notes Explorer** provides both a fixed-height grid (Gallery) and a fluid masonry layout[^51].
*   **Visual Styling:** Features like **tag-based color indicators** (where cards are colored based on contained tags), the ability to hide footers for a clean look, and configurable tag color priorities via drag-and-drop are standard[^51].
*   **Interactivity & UX:** Enhancements include opening notes on double-click to prevent accidents, hover previews for internal links and parent notes (when holding CTRL), and a dedicated refresh button[^51].
*   **Performance Optimizations:** **Notes Explorer** intelligently reads only the first few lines of a note (default 20) to extract metadata, significantly improving performance with large vaults[^51].

**Interactivity & Data Manipulation (Key Limitation):**
Interactivity in these plugins is largely **navigational and presentational**. You can click to open notes, hover to preview, and sometimes sort based on basic metadata like created time or filename[^51]. **Crucially, they lack the ability to edit note properties (frontmatter) directly from the card view.** There is no bidirectional sync where changing a tag on a card updates the note's source file. They are best described as **read-only visual browsers**.

**Integration:**
Their integration is often minimal beyond reading standard note properties. They are not designed to be part of a larger data management workflow like Projects or DB Folder.

**The verdict is clear: specialized gallery plugins are exceptionally effective for creating beautiful, passive visualizations—ideal for portfolios, media libraries, or dashboards for review. However, they cannot function as interactive databases for managing and manipulating structured data, which is the essence of Notion's Gallery View.**

### 5.5 Synthesis: Mapping Functionality to the Notion Multi-View Paradigm

The analysis reveals that replicating Notion's List and Gallery View experience in Obsidian requires understanding a fundamental trade-off between **interactive data management** and **advanced visual presentation**. The ecosystem does not provide a single plugin that perfectly unifies both roles.

The following table synthesizes the key findings to highlight the distinct paradigms:

| Paradigm | Representative Plugins | Core Strength | Primary Limitation vs. Notion | Ideal Use Case |
| :--- | :--- | :--- | :--- | :--- |
| **Interactive Multi-View Database** | Obsidian Projects, DB Folder | **Editable views with filtering/sorting.** Projects offers synchronized views; DB Folder offers superior query integration and complex filtering. | **Visual customization is functional, not artistic.** Gallery views are less visually rich than specialized plugins. Projects' query-based sources are read-only. | Managing a project or collection where you need to view, filter, and edit note properties through different layouts (list, table, gallery). |
| **Specialized Visualizer / Gallery** | Notes Explorer, Note Gallery, Image Gallery | **Superior visual aesthetics and layout control** (masonry, tag colors, hover previews). Optimized for browsing and discovery. | **Lacks interactive editing.** Cannot modify note data from the view. Simpler, less flexible data sourcing. | Creating a portfolio, media library, or revision dashboard where the primary goal is visual browsing and navigation, not data manipulation. |

**Key Gaps in the Obsidian Ecosystem:**
1.  **Fragmentation of Function:** Notion seamlessly combines deep data manipulation with rich visualization in a single interface. In Obsidian, this is split: use DB Folder for editing and complex queries, then use Notes Explorer for a prettier, non-editable display of the same folder. **There is no unified tool that does both excellently.**
2.  **Lack of a Universal Relational Model:** As highlighted in discussions about Dataview, relations in Obsidian are often unidirectional and require careful manual setup[^54]. This undermines the seamless "related database" experience central to Notion.
3.  **Read-Only Limitations of Powerful Queries:** The fact that Projects renders Dataview queries as read-only views[^49] exemplifies the technical barrier to making arbitrarily queried data fully interactive.

**Unique Strengths of the Obsidian Approach:**
1.  **Unparalleled Visual Customization:** Through CSS and plugins like Notes Explorer, users can create gallery views that are far more unique and visually tailored than anything in Notion.
2.  **Local Performance & Composability:** Users can mix and match plugins. A common advanced workflow might involve using **DB Folder to manage data** (leveraging its Dataview source and filtering), and then embedding or viewing that data in a **Notes Explorer** pane for a superior visual experience during review sessions.

**Practical Selection Guidelines:**
To choose the right tool, users should answer a simple question: **"Do I need to edit the data from this view, or am I just browsing?"**

*   **Choose a Comprehensive Database Plugin (Projects or DB Folder) if:**
    *   You are managing a collection (books, projects, contacts) and need to update status, dates, or other properties directly from a list or card view.
    *   You need to apply complex, ad-hoc filters to your data.
    *   You want this view to stay synchronized with other perspectives (like a Table or Kanban board) on the same data.
    *   *Selection Tip:* Prefer **DB Folder** for maximum query flexibility and powerful filtering. Prefer **Projects** if you want a built-in, multi-view hub for project management.

*   **Choose a Specialized Gallery Plugin (Notes Explorer, Image Gallery) if:**
    *   Your primary goal is to create a beautiful, visually engaging dashboard or portfolio.
    *   You are reviewing or revising notes and want a dense, aesthetically pleasing overview.
    *   The data is largely static, and any edits will be done by opening the note in the editor, not from the gallery.
    *   *Selection Tip:* **Notes Explorer** is ideal for note-based galleries with rich customization. **Image Gallery** is perfect for pure image collections.

**Conclusion:** No single Obsidian plugin fully replicates the integrated, editable List and Gallery View experience of Notion. The ecosystem instead offers powerful, specialized tools on either side of a spectrum: **database managers** for interactivity and **visualizers** for presentation. The most Notion-like experience is achieved by **DB Folder**, which comes closest to being an interactive, query-backed database with view customization. However, users seeking the visual polish of Notion's Gallery must look to specialized plugins, accepting the loss of inline edit functionality. This fragmentation is the price and the power of Obsidian's modular, local-first philosophy.

## 6 Synthesis: Towards a Cohesive Multi-View System

This chapter synthesizes the findings from the comparative analysis of Obsidian plugins across Table, Kanban, Calendar, List, and Gallery views to provide a holistic assessment of the ecosystem's capability to replicate Notion's seamless multi-view database experience. It moves beyond individual plugin evaluations to analyze the overarching architectural patterns, systemic strengths, and fundamental challenges. The core analysis focuses on key challenges such as data source fragmentation, the absence of a unified relational data model, and the inherent workflow complexity introduced by plugin composability. This is contrasted with the unique advantages of the Obsidian approach, including unparalleled flexibility, local-first control, and deep customization. The chapter concludes by outlining the current state of the ecosystem, its suitability for different user archetypes, and potential future directions for achieving greater cohesion.

### 6.1 Architectural Analysis: The Fragmented vs. Unified Paradigm

The comparative analysis reveals a fundamental architectural schism between Notion's design and the Obsidian plugin ecosystem. This divergence defines the core challenge in replicating Notion's experience and simultaneously explains Obsidian's unique value proposition.

**The Unified Paradigm of Notion** is built upon a **centralized, block-based relational database**. In this model, a single, structured dataset—composed of pages (rows) with properties (columns)—serves as the sole source of truth. The Table, Board, Calendar, Gallery, and List views are merely different, fully synchronized *lenses* onto this dataset. A filter applied in the Calendar view persists when switching to the Board view; editing a property on a card in the Gallery instantly updates the same record in the Table. This is enabled by a unified backend where every element is a dynamically addressable block, creating a seamless, bidirectional flow between data and its visualization.

**In stark contrast, Obsidian operates on a Fragmented Paradigm**, distributing database-like functionality across a constellation of specialized plugins, each with its own data model and interaction logic. This fragmentation manifests in several critical ways:

*   **Data Silos:** Plugins source data from incompatible or only partially overlapping origins. **Dataview** dynamically queries across the vault using folders, tags, and frontmatter but produces static, non-interactive outputs. **Obsidian Bases** provides a native, interactive table but can only work with file properties (frontmatter), not arbitrary note content. **Task Board** aggregates tasks from specific YAML-filtered notes, while the core **Kanban** plugin manages a self-contained board file. This creates data silos where the same conceptual "project" might exist as a frontmatter property in Bases, a task in a note for Task Board, and a card in a separate Kanban file, with no automatic synchronization between them.

*   **Inconsistent Interaction Models:** The user experience is not cohesive. Changing a view in Dataview requires editing query code, while in Bases it involves clicking UI sort/filter controls. Drag-and-drop card movement is native in the Kanban plugin but was a planned, later addition for Task Board. This lack of a consistent interaction model across different "views" of one's data increases cognitive load.

*   **Absence of a Native Relational Backend:** Crucially, Obsidian lacks a native, file-system-integrated relational database engine. Relations must be manually constructed using links and then queried with tools like Dataview, or managed within plugins like **DB Folder** which implements its own logic for linking files. This undermines the seamless "related database" experience that is central to Notion. The ecosystem's strength—plain text files—becomes a limitation for complex, bidirectional data relationships.

**The fundamental takeaway is that Obsidian does not have a "database" in the Notion sense.** Instead, it has a **toolkit of database *visualizers* and *managers*** that operate on the common substrate of Markdown files, but without a unified protocol for interaction or a shared relational model. This architectural reality is the root cause of the gaps identified in each view-specific analysis.

### 6.2 Systemic Challenges and Trade-offs

Building upon the architectural analysis, the Obsidian ecosystem presents users with a coherent set of systemic challenges and trade-offs when attempting to assemble a Notion-like multi-view system.

1.  **Data Source and Model Fragmentation:** The most significant challenge is the inability of plugins to seamlessly interact with a common, editable dataset. This is vividly illustrated by **Obsidian Projects**, which can use a Dataview query as a source for its Gallery and other views but must render them as **read-only** because it cannot safely write back to dynamically queried notes. Similarly, a manual **Kanban** board exists in isolation from the notes it might represent. Users must choose a primary data model (file-with-properties for Bases, scattered tasks for Task Board, query results for Dataview) and accept that plugins outside that model will have limited or no access.

2.  **Workflow and Configuration Complexity:** Achieving functionality comparable to Notion requires mastering multiple plugins, each with its own configuration syntax and UI paradigm. A user must learn **DQL** for Dataview, configure **YAML** frontmatter for Bases and Task Board filters, understand specific date formats for Big Calendar parsing, and potentially write **CSS snippets** for theming the Kanban plugin. This contrasts sharply with Notion's consistent, point-and-click interface. The complexity is the price of flexibility, creating a steep learning curve and ongoing maintenance overhead.

3.  **Interactivity and Synchronization Gaps:** Core Notion features are only partially implemented or entirely absent across the plugin landscape.
    *   **Bidirectional Editing:** While **Bases** and **DB Folder** support inline editing that writes back to files, most other visualizations (Dataview tables, specialized galleries like **Notes Explorer**) are read-only presentations.
    *   **Client-Side Interactivity:** The long-standing community request for client-side filtering and sorting in **Dataview** tables remains unfulfilled, a key gap compared to Notion's responsive UI controls.
    *   **Real-Time Collaboration:** A fundamental weakness of Obsidian for team use is the lack of native, real-time multiplayer editing in its free version, a core strength of Notion's cloud-based boards and databases.

4.  **Performance and Maintenance Considerations:** Users trade cloud latency for local processing power, but this introduces different considerations.
    *   **Plugin Overhead:** Running multiple powerful plugins like Dataview, Full Calendar, and DB Folder simultaneously can impact Obsidian's startup time and general responsiveness, especially on mobile or with very large vaults.
    *   **Dependency on Developer Roadmaps:** The ecosystem's health is tied to individual maintainers. The **stalled development of Dataview** and the many **open pull requests for the Kanban plugin** exemplify the risk of relying on community plugins for critical workflows. The emergence of successors like Datacore and forks like **Kanban Plus** are direct responses to this fragility.

**These are not mere feature omissions but inherent trade-offs of Obsidian's design philosophy.** The decentralized, file-based, modular approach inherently sacrifices the cohesion and simplicity of a centrally designed, cloud-hosted platform like Notion. The user's task is to determine whether the compensatory strengths are worth this cost.

### 6.3 Unique Strengths and Adaptive Advantages of the Obsidian Ecosystem

While the challenges are significant, the Obsidian plugin ecosystem offers a powerful set of compensatory strengths that create a different, and for many, superior value proposition. These strengths often arise directly from the very fragmentation that creates the challenges.

1.  **Unparalleled Flexibility and Customization:** Obsidian users are not confined to a single vendor's vision of a database. They can **compose a best-in-class toolkit** by mixing specialized plugins. For example, one could use **DB Folder** for its powerful Dataview-based sourcing and complex UI filtering to manage a project, and then use **Notes Explorer** to create a stunning, visually customized masonry gallery view of the same project folder for presentation or review. Deep theming via CSS (as practiced with the Kanban plugin) allows for aesthetic control far beyond Notion's theme options.

2.  **Local-First Control and Data Portability:** This is the foundational advantage. All data resides in plain-text Markdown files on the user's device. This guarantees **long-term data ownership, privacy, and access** independent of any plugin's future or a company's viability. It also means performance is not subject to cloud server latency or degradation. **This directly addresses a key Notion weakness: performance degradation with databases over 5,000 records.** In Obsidian, performance is limited by local hardware and plugin efficiency, not a remote service tier.

3.  **Deep, Organic Integration with Notes:** Unlike Notion, which often requires data to be structured inside a database table, powerful Obsidian plugins like **Task Board** and **Big Calendar** build their views by **parsing and aggregating content that lives naturally within notes**. Your schedule emerges from time blocks written in your daily notes; your project Kanban is built from tasks embedded within your research documentation. This supports a "note-centric" workflow where the primary artifact is the note, and database views are dynamic aggregations, not separate data silos.

4.  **Community-Driven Innovation and Specialization:** The open plugin architecture fosters rapid innovation to fill niche workflow gaps. This has led to **highly specialized visualization tools that have no equivalent in Notion**, such as **Heatmap Calendar** for quantitative habit tracking or **Time Ruler** for integrated drag-and-drop timeline planning. The community's ability to identify needs (e.g., Kanban-to-Calendar sync) and implement solutions, sometimes rapidly with the aid of modern development tools, keeps the ecosystem dynamic and closely aligned with user needs.

**In essence, the Obsidian ecosystem does not aim to replicate the Notion database as a monolithic product. Instead, it provides a **meta-toolkit for building personalized information systems**. The fragmentation is not merely a flaw; it is the source of its adaptive power, allowing users to tailor a system that aligns precisely with their specific workflow, aesthetic preferences, and philosophical stance on data ownership.

### 6.4 Synthesis and Practical Roadmap for Users

The core research question—"Which Obsidian plugins can effectively replicate Notion's multi-view database?"—yields a nuanced answer. **No single Obsidian plugin provides a complete, drop-in replacement for Notion's seamless, integrated multi-view database.** The ecosystem collectively surpasses Notion in specific dimensions (flexibility, control, deep note integration, specialization) but does so at the cost of native cohesion and out-of-the-box simplicity.

The current state of the ecosystem is one of **powerful, parallel paradigms** rather than a unified system. Users must therefore select plugins not just by feature checklist, but by aligning with the underlying paradigm that matches their primary need and working style. The following practical roadmap synthesizes the findings into actionable guidance for key user archetypes:

| User Archetype | Core Need & Mindset | Recommended Plugin Stack | Rationale & Trade-off Accepted |
| :--- | :--- | :--- | :--- |
| **The Programmatic Power User** | Maximum flexibility; thinks in queries and scripts; values data transformation over immediate UI polish. | **Primary Engine:** Dataview (or Datacore) for dynamic queries. **Interactive Layer:** DB Folder to make query results editable with advanced filtering. **Visualization:** Custom DataviewJS tables/calendars or Heatmap Calendar for specialized views. | Leverages the full query power of the vault. Accepts the complexity of code (DQL/JS) and the fact that a truly seamless, Notion-like UI is constructed, not provided. |
| **The Visual File Manager** | Direct, WYSIWYG manipulation of notes and their properties; prefers intuitive interfaces over code. | **Core Tools:** Obsidian Bases for interactive tables of file properties. **Kanban** (or Kanban Plus) for manual project boards. **Full Calendar** or **Big Calendar** for event management. | Gains a native-feeling, interactive experience for managing collections of files. Accepts the limitation that data must be structured in file frontmatter and that boards/calendars are separate from the core table view. |
| **The Project Orchestrator** | Needs an integrated hub to manage complex projects with tasks, notes, and multiple synchronized views. | **Integrated System:** Obsidian Projects for a built-in multi-view hub (Table, Board, Calendar, Gallery). **Enhanced Capability:** Task Board for automated, dependency-aware task aggregation from across the vault. | Gets the closest to a "single pane of glass" for project management within Obsidian. Accepts that Projects' query-based sources are read-only and that integrating with other data sources may require workarounds. |
| **The Specialized Visualizer** | Primary goal is creating beautiful, insightful dashboards, portfolios, or activity overviews; editing is secondary. | **Presentation Layer:** Notes Explorer for aesthetically rich note galleries. **Image Gallery** for pure media collections. **Heatmap Calendar** for long-term metric tracking. | Achieves visual results that far exceed Notion's standardized Gallery view. Accepts that these are primarily read-only browsing and discovery tools, not surfaces for data manipulation. |

**Future Directions and Convergence:** The ecosystem is not static. The development of native **Obsidian Bases** and community calls for **standardized date/time formats** indicate a movement towards reducing fragmentation. A future where **Bases gains a Calendar View and more relational features** could provide a more cohesive core experience, while the vibrant community continues to build specialized tools around it. For now, users must embrace the composable nature of Obsidian, understanding that building a Notion-like system is an exercise in **strategic plugin selection and workflow design**, trading off cohesion for unparalleled control and adaptability. The "database" is not a plugin you install; it is the personalized system you architect from the components available.

# 参考内容如下：
[^1]:[The data model behind Notion's flexibility](https://www.notion.com/blog/data-model-behind-notion)
[^2]:[Views, filters, sorts & groups – Notion Help Center](https://www.notion.com/help/views-filters-and-sorts)
[^3]:[Using database views](https://www.notion.com/help/guides/using-database-views)
[^4]:[When to use each type of database view](https://www.notion.com/help/guides/when-to-use-each-type-of-database-view)
[^5]:[Notion Database Views: Everything You Need To Know ...](https://www.landmarklabs.co/insights/notion-database-views)
[^6]:[Board view – Notion Help Center](https://www.notion.com/help/boards)
[^7]:[Relations & rollups – Notion Help Center](https://www.notion.com/help/relations-and-rollups)
[^8]:[Using relation & rollup properties](https://www.notion.com/help/guides/using-relation-and-rollup-properties)
[^9]:[Notion Review 2026: Complete Test & Real Team ...](https://hackceleration.com/notion-review/)
[^10]:[Performance · The Ultimate Notion vs ...](https://coda.io/@noah/the-2024-ultimate-notion-vs-coda-evaluation-guide/performance-27)
[^11]:[I am creating an beginner's FAQ for Database Folder. This ...](https://forum.obsidian.md/t/i-am-creating-an-beginners-faq-for-database-folder-this-is-what-i-got-so-far-any-suggestions-about-what-i-should-add-correct/76663)
[^12]:[What are the differences between various database plugins?](https://forum.obsidian.md/t/what-are-the-differences-between-various-database-plugins/39406)
[^13]:[A case against Dataview - A story - Knowledge management](https://forum.obsidian.md/t/a-case-against-dataview-a-story/82210)
[^14]:[Dataview vs Datacore vs Obsidian Bases](https://obsidian.rocks/dataview-vs-datacore-vs-obsidian-bases/)
[^15]:[Structure of a Query - Dataview](https://blacksmithgu.github.io/obsidian-dataview/queries/structure/)
[^16]:[Responsive Views? Filtering & Sorting for tables · Issue #218](https://github.com/blacksmithgu/obsidian-dataview/issues/218)
[^17]:[Dataviewjs: table with sort buttons and filter fields? - Help](https://forum.obsidian.md/t/dataviewjs-table-with-sort-buttons-and-filter-fields/81606)
[^18]:[Good hands on examples of dataview - Help](https://forum.obsidian.md/t/good-hands-on-examples-of-dataview/46830)
[^19]:[Introduction to Bases](https://help.obsidian.md/bases)
[^20]:[Obsidian Bases — What are they good for (And ... - Nick Felker](https://fleker.medium.com/obsidian-bases-what-are-they-good-for-and-what-are-they-not-da620006cb34)
[^21]:[pistacchio/obsidian-enhanced-tables](https://github.com/pistacchio/obsidian-enhanced-tables)
[^22]:[Enhaced tables plugin - Share & showcase](https://forum.obsidian.md/t/enhaced-tables-plugin/75824)
[^23]:[Plugins - Obsidian](https://obsidian.md/plugins?search=Kanban)
[^24]:[Introducing the Obsidian Kanban Plus Plugin - Medium](https://medium.com/@geetduggal/introducing-the-obsidian-kanban-plus-plugin-3c970c21141a)
[^25]:[Task Board - Similar to GitHub Projects Planning](https://forum.obsidian.md/t/task-board-another-gtd-methodology-similar-to-github-projects-planning/90849)
[^26]:[Plugin : CardBoard (a kanban for your markdown tasks)](https://forum.obsidian.md/t/plugin-cardboard-a-kanban-for-your-markdown-tasks/28314)
[^27]:[CardBoard - An Obsidian plugin to make working with ...](https://www.obsidianstats.com/plugins/card-board)
[^28]:[Pull requests · mgmeyers/obsidian-kanban](https://github.com/mgmeyers/obsidian-kanban/pulls)
[^29]:[Kanban Board Plugin - Custom CSS & Theme Design](https://forum.obsidian.md/t/kanban-board-plugin/70903)
[^30]:[Known Limitations - Tasks User Guide](https://publish.obsidian.md/tasks/Support+and+Help/Known+Limitations)
[^31]:[Obsidian Reviews, Pros and Cons](https://www.softwareadvice.com/help-desk/obsidian-profile/reviews/)
[^32]:[Obsidian vs. Notion: What's Different and What to Use When](https://learn.g2.com/obsidian-vs-notion?hsLang=en)
[^33]:[Plugins - Obsidian](https://obsidian.md/plugins?search=Calendar)
[^34]:[liamcain/obsidian-calendar-plugin](https://github.com/liamcain/obsidian-calendar-plugin)
[^35]:[New plugin: Daily note calendar - Share & showcase](https://forum.obsidian.md/t/new-plugin-daily-note-calendar/92087)
[^36]:[Full Calendar - Keep events and manage your ...](https://www.obsidianstats.com/plugins/obsidian-full-calendar)
[^37]:[obsidian-community/obsidian-full-calendar](https://github.com/obsidian-community/obsidian-full-calendar)
[^38]:[Big Calendar | Boninall](https://boninall.com/projects/obsidian-big-calendar)
[^39]:[Quorafind/Obsidian-Big-Calendar](https://github.com/Quorafind/Obsidian-Big-Calendar)
[^40]:[Plugins - Obsidian](https://obsidian.md/plugins?search=task)
[^41]:[Richardsl/heatmap-calendar-obsidian](https://github.com/Richardsl/heatmap-calendar-obsidian)
[^42]:[Heatmap Calendar - An Obsidian plugin for displaying data ...](https://www.obsidianstats.com/plugins/heatmap-calendar)
[^43]:[Tech Habits: Obsidian Kanban and Full Calendar Integration](https://medium.com/@geetduggal/tech-habits-obsidian-kanban-and-full-calendar-integration-a05a7ff2d2f6)
[^44]:[Obsidian-Tasks-Calendar - Share & showcase](https://forum.obsidian.md/t/obsidian-tasks-calendar/45939)
[^45]:[Dataview + Full Calendar for daily agenda - Help](https://forum.obsidian.md/t/dataview-full-calendar-for-daily-agenda/44185)
[^46]:[Task management devs - define a shared date and action ...](https://forum.obsidian.md/t/task-management-devs-define-a-shared-date-and-action-format/26464)
[^47]:[Core plugin for dealing with tasks and dates](https://forum.obsidian.md/t/core-plugin-for-dealing-with-tasks-and-dates/66234)
[^48]:[Base: Calendar view - Feature requests](https://forum.obsidian.md/t/base-calendar-view/104383)
[^49]:[Announcing Obsidian Projects - Marcus Olsson](https://marcusolsson.dev/announcing-obsidian-projects/)
[^50]:[RafaelGB/obsidian-db-folder](https://github.com/RafaelGB/obsidian-db-folder)
[^51]:[Explore your notes in masonry and grid view](https://forum.obsidian.md/t/notes-explorer-explore-your-notes-in-masonry-and-grid-view/93135)
[^52]:[Plugins - Obsidian](https://obsidian.md/plugins?search=gallery)
[^53]:[Displaying data - Database Folder](https://rafaelgb.github.io/obsidian-db-folder/features/Displaying%20data/)
[^54]:[Toying with Relational Databases using Dataview](https://forum.obsidian.md/t/toying-with-relational-databases-using-dataview/17433)
